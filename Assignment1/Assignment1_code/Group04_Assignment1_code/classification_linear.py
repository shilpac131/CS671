# -*- coding: utf-8 -*-
"""LS.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1oKSTMhLn9NF_i9uORrfDrYpos7MaHOiP
"""

'''from google.colab import drive
drive.mount('/content/drive')'''

"""**Importing the libraries**"""

import numpy as np
import pandas as pd
from matplotlib import pyplot as plt

"""**Getting the data file path**"""

data_1_path = "/home/ananya/Downloads/Group04/Classification/LS_Group04/Class1.txt"
data_2_path = "/home/ananya/Downloads/Group04/Classification/LS_Group04/Class2.txt"
data_3_path = "/home/ananya/Downloads/Group04/Classification/LS_Group04/Class3.txt"

"""**Reading the input data**"""

def input_data(data_1_path, data_2_path, data_3_path):
  class1 = pd.read_table(data_1_path, header=None, delimiter=" ")
  class2 = pd.read_table(data_2_path, header=None, delimiter=" ")
  class3 = pd.read_table(data_3_path, header=None, delimiter=" ")
  return class1, class2, class3

"""**Spliting the data in training and testing (70%, 30%)**

---


"""

def split_train_test(data):
  # Select ratio
  ratio = 0.70
  
  total_rows =data.shape[0]
  train_size = int(total_rows*ratio)
  
  # Split data into test and train
  train = data[0:train_size]
  test = data[train_size:]
  return train, test

"""**Defining Plot function**"""

def plotting(class1,class2,class3):
  plt.scatter(class1[0], class1[1],color="blue")   
  plt.scatter(class2[0], class2[1],color="orange")
  plt.scatter(class3[0], class3[1], color="green") 
  plt.legend(['Class 1', 'Class 2', 'Class 3' ])
  plt.title("Input Data")
  plt.show()

"""**Input data Plotting**"""

class1, class2, class3 = input_data(data_1_path, data_2_path, data_3_path)
plotting(class1,class2,class3)

train_d1, test_d1 = split_train_test(class1)
train_d2, test_d2 = split_train_test(class2)
train_d3, test_d3 = split_train_test(class3)
#print(class1.shape)

"""**Sigmoidal Function**"""

def sigmoidal(x):
  return 1/(1+np.exp(-(x)))

"""**model training function**"""

def train_fun(xn,y):
  p,q = xn.shape[0],xn.shape[1]
  
  w = np.array([1,0.5,0.3]) #initializing weight
  er = []
  avg_er = []
  epoch = 100
  lr = 0.3 #learning rate
  
  while (epoch):
    for i in range (p):
      an=activation_val(xn,w,i)
      sn = sigmoidal(an)
      if i<y:
        yn = 0
      else:
        yn = 1
      error=compute_error(yn,sn)
      er.append(error) 
      w=gradient_descent(lr,yn,sn,xn,i,w)
    er_avg = sum(er)/len(er)
    avg_er.append(er_avg)
    epoch = epoch- 1
    
  print("Updated weight parameter: ",w)
  print("The Average Error: ", round(er_avg,5))
  return w, avg_er

def activation_val(xn,w,i):
    xi=[1,xn.iloc[i,0], xn.iloc[i,1]]
    an=np.dot(w.T,xi)
    return an

def compute_error(yn,sn):
  error = 0.5*(yn-sn)**2
  return error

def gradient_descent(lr,yn,sn,xn,i,w):
  d_w = lr*(yn-sn)*sn*(1-sn)
  d_w = activation_val(xn,d_w,i)
  w = w + d_w
  return w

"""**training the model**

Training model for class 1 and class 2
"""

tr_cl_12 = train_d1.append(train_d2)
w12, avg_er_12 = train_fun(tr_cl_12,len(train_d1))

"""Training model for class 1 and class 3"""

tr_cl_13 = train_d1.append(train_d3)
w13, avg_er_13 = train_fun(tr_cl_13, len(train_d1))

"""Training model for class 2 and class 3"""

tr_cl_23 = train_d2.append(train_d3)
w23, avg_er_23 = train_fun(tr_cl_23, len(train_d2))

"""**Testing the trained model**"""

def testing(xn, w):
    m, n = xn.shape
    yp = []
    for i in range(m):
        an=activation_val(xn,w,i)
        yi = sigmoidal(an)
        yp.append(yi)
    ypre=[]
    for i in range(m):
      if yp[i]<0.5:
        ypre.append(0)
      else:
        ypre.append(1)
    return ypre

"""**Plotting** **Decision Boundary between two class** """

def decision_boundary(all_points, data, w, name):
    
    c1x_, c2x_, c1y_, c2y_ = [], [], [], []
    c1, c2 = [], []
    
    ypre = testing(all_points, w)
    m, n = all_points.shape
    for i in range(m):
        if ypre[i]== 0:
            c1x_.append(all_points.iloc[i, 0])
            c1y_.append(all_points.iloc[i, 1])
            c1.append((all_points.iloc[i, 0],all_points.iloc[i, 1]))
        else:
            c2x_.append(all_points.iloc[i, 0])
            c2y_.append(all_points.iloc[i, 1])
            c2.append((all_points.iloc[i, 0],all_points.iloc[i, 1]))

    plt.scatter(c1x_, c1y_, marker='s', s=500, c= "pink")
    plt.scatter(c2x_, c2y_, marker='s', s=500, c= "yellow")
    plt.scatter(data.iloc[:,:1], data.iloc[:,1:2], edgecolors='black')

    plt.title("Decision Boundary (Class"+name[0]+name[1]+")")
    plt.tight_layout()
   # plt.savefig(""+name[0]+name[1]+".png")
    plt.show()
    
    return [c1, c2]

max_x_val = int(max([max(class1.iloc[0]), max(class2.iloc[0]), max(class3.iloc[0])]))
min_x_val = int(min([min(class1.iloc[0]), min(class2.iloc[0]), min(class3.iloc[0])]))
max_y_val = int(max([max(class1.iloc[1]), max(class2.iloc[1]), max(class3.iloc[1])]))
min_y_val = int(min([min(class1.iloc[1]), min(class2.iloc[1]), min(class3.iloc[1])]))
all_points = []
for i in range(min_x_val-7, max_x_val+30):
    for j in range(min_y_val-5, max_y_val+5):
        all_points.append([i, j])
        

all_points = pd.DataFrame(all_points)     
#all_points

class12T = test_d1.append(test_d2)
b12 = decision_boundary(all_points, class12T, w12, ['1', '2'])

class13T = test_d1.append(test_d3)
b13 = decision_boundary(all_points, class13T, w13, ['1', '3'])

class23T = test_d2.append(test_d3)
b23 = decision_boundary(all_points, class23T, w23, ['2', '3'])

"""**Merging all three decision boundries**"""

b1 = list(set.intersection(set(b12[0]), set(b13[0])))
b2 = list(set.intersection(set(b12[1]), set(b23[0])))
b3 = list(set.intersection(set(b13[1]), set(b23[1])))
b1x, b1y = [i[0] for i in b1], [i[1] for i in b1]
b2x, b2y = [i[0] for i in b2], [i[1] for i in b2]
b3x, b3y = [i[0] for i in b3], [i[1] for i in b3]

plt.scatter(b1x, b1y, marker='s', s=500, c="yellow")
plt.scatter(b2x, b2y, marker='s', s=500, c="cyan")
plt.scatter(b3x, b3y, marker='s', s=500, c="pink")


plt.scatter(class1[0], class1[1], edgecolors='black')
plt.scatter(class2[0], class2[1], edgecolors='black')
plt.scatter(class3[0], class3[1], edgecolors='black')
plt.legend(['Class 1','Class 2','Class 3'])
plt.title("Complete Decision Boundary")
plt.xlim(-12, 20)
plt.ylim(-20, 12)

plt.show()

"""**Error vs Epoch graph Plotting**"""

plt.plot(avg_er_12, color="orange")
plt.plot(avg_er_13, color="black")
plt.plot(avg_er_23, color="blue")
plt.legend(['Class 1','Class 2','Class 3'])
plt.title("Error vs Epoch")
plt.xlabel("Epoch")
plt.ylabel(" Error")
#plt.savefig(" ")
plt.show()

"""**Confusion Matrix**"""

def confusion_matrix(predicted, k):
    matrix = 0
    c1, c2 = 0, 0
    for i in range(len(predicted)):
        if i<k and predicted[i] == 0:
            c1 += 1
        elif i>=k and predicted[i] == 1:
            c2 += 1
            
    return [[c1, k-c1], [k-c2, c2]]

"""**Confusion matrix for class 1 and class 2**"""

#class12
pred12 = testing(class12T, w12)
matrix12 = confusion_matrix(pred12, len(test_d1))
print("Confusion matrix for class 1 and class 2\n ",np.array(matrix12))

"""**Confusion matrix for class 2 and class 3**


"""

#class23
pred23 = testing(class23T, w23)
matrix23 = confusion_matrix(pred23, len(test_d2))
print("Confusion matrix for class 2 and class 3\n",np.array(matrix23))

"""**Confusion matrix for class 1 and class 3**"""

#class13
pred13 = testing(class13T, w13)
matrix13 = confusion_matrix(pred13, len(test_d1))
print("Confusion matrix for class 1 and class 3\n",np.array(matrix13))

"""**Confusion matrix for 3 classes**"""

#Overall Confusion Matrix
c11 = matrix12[0][0]+matrix13[0][0]
c12 = matrix12[0][1]
c13 = matrix13[0][1]

c21 = matrix12[1][0]
c22 = matrix12[1][1]+matrix23[0][0]
c23 = matrix23[0][1]

c31 = matrix13[1][0]
c32 = matrix23[1][0]
c33 = matrix13[1][1]+matrix23[1][1]

confusionmatrix = [[c11, c12, c13], [c21, c22, c23], [c31, c32, c33]]
print("Confusion Matrix")
print(np.array(confusionmatrix))

"""**Accuracy**"""

accuracy = (c11+c22+c33)/(2*(len(test_d1)+len(test_d2)+len(test_d3)))*100
print('Accuracy = {}%'.format(accuracy))

"""**Precision**"""

def function(x, y):
    return x/(x+y)
precision_1 = function(c11/2, c12+c13)
precision_2 = function(c22/2, c21+c23)
precision_3 = function(c33/2, c31+c32)
print('Precision\nClass1 = {}, Class2 = {}, Class3 = {}'.format(precision_1, precision_2, precision_3))

print("Average Precision: ", (precision_1+precision_2+precision_3)/3)
result=[]
result.append(accuracy)

"""**Recall**"""

recall_1 = function(c11/2, c21+c31)
recall_2 = function(c22/2, c12+c32)
recall_3 = function(c33/2, c13+c23)
print('Recall\nClass1 = {}, Class2 = {}, Class3 = {}'.format(recall_1, recall_2, recall_3))

print("Average Recall: ", (recall_1+recall_2+recall_3)/3)
result.append((recall_1+recall_2+recall_3)/3)

"""**F_measure**"""

f_measure1 = (2*precision_1*recall_1)/(precision_1+recall_1)
f_measure2 = (2*precision_2*recall_2)/(precision_2+recall_2)
f_measure3 = (2*precision_3*recall_3)/(precision_1+recall_3)
print('F Score\nClass1 = {}, Class2 = {}, Class3 = {}'.format(f_measure1, f_measure2, f_measure3))

print("Average F-measure: ", (f_measure1+f_measure2+f_measure3)/3)
result.append((f_measure1+f_measure2+f_measure3)/3)


