# -*- coding: utf-8 -*-
"""n_8classification_non_linear.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1quYO-aEfiuInmD7By8AmzRyRi6ydVqqe
"""

import pandas as pd
from matplotlib import pyplot as plt
import numpy as np
from numpy import linalg

# from google.colab import drive
# drive.mount('/content/drive/')

path = "/home/ananya/Downloads/Group04/Classification/NLS_Group04.txt"

data = pd.read_csv(path, header=None, delimiter=" ")
data = pd.DataFrame(data)
data = data.drop([2], axis=1)

class1 = data.iloc[:300]
class2 = data.iloc[300:800]
class3 = data.iloc[800:1800]

plt.scatter(class1[0], class1[1])
plt.scatter(class2[0], class2[1])
plt.scatter(class3[0], class3[1])

plt.legend(['Class 1','Class 2','Class 3'])
plt.title("Input Data")
plt.show()

def split_data(data):
    m, n = data.shape
    l1 = int(0.6*m)
    l2 = l1 + int(0.2*m)
    print(l1, l2)
    training = data.iloc[:l1]
    validation = data.iloc[l1:l2]
    test = data.iloc[l2:m]
    
    return training, validation, test

training1, validation1, test1 = split_data(class1)
training2, validation2, test2 = split_data(class2)
training3, validation3, test3 = split_data(class3)

tr1, tr2 = len(training1), len(training2)
v1, v2 = len(validation1), len(validation2)
t1, t2 = len(test1), len(test2)

training = training1.append(training2, ignore_index=True)
training = training.append(training3, ignore_index=True)

validation = validation1.append(validation2, ignore_index=True)
validation = validation.append(validation3, ignore_index=True)

testing = test1.append(test2, ignore_index=True)
testing = testing.append(test3, ignore_index=True)

def sigmoid(x):
    return 1/(1+np.exp(-(x)))

def inst_error(y, yp):
    return sum(0.5*(y-yp)**2)

def train_data(xn, l1, l2):

    wh1 = 0.10*np.random.randn(3, 8)
    wh2 = 0.10*np.random.randn(8, 3)
    wo = 0.10*np.random.randn(3, 3)
    avg_err = []
    epoch = 1000
    
    while(epoch):
    
        err = []
        c1, c2, c3 = 0, 0, 0
        
        for i in range(len(xn)):

            xi = [1, xn.iat[i,0], xn.iat[i,1]] #Input layer
            #--------------------------
            h1 = np.dot(wh1.T, xi) #hidden layer 1 out
            a1 = sigmoid(h1) #hidden layer 1 activation out
            #--------------------------
            h2 = np.dot(wh2.T, a1) #hidden layer 2 out
            a2 = sigmoid(h2) #hidden layer 2 activation out
            #--------------------------
            out = np.dot(wo.T, a2) #Output layer out
            ao = sigmoid(out) #Output activation 
            #--------------------------

            if i<l1:
                y = [1, 0, 0]
                en = inst_error(y, ao)
                c1+=1
            elif i>=l1 and i<(l1+l2):
                y = [0, 1, 0]
                en = inst_error(y, ao)
                c2+=1
            else:
                y = [0, 0, 1]
                en = inst_error(y, ao)
                c3+=1
                
                
            err.append(en)
            neta = 0.01
            
            #Update weights
            wo = wo + (neta * np.outer(a2, ((y-ao) * ao * (1-ao))))
            
            var1 = np.dot(wo, ((y-ao) * ao * (1-ao)))
            var2 = a2 * (1-a2)
            wh2 = wh2 + (neta * np.outer(a1, var1*var2))
            
            var3 = var1*var2
            var4 = np.dot(wh2, var3)
            var5 = a1 * (1-a1)
            wh1 = wh1 + (neta * np.outer(xi, var4*var5))

            
        avg_error = sum(err)/len(err)
        avg_err.append(avg_error)
        if epoch%10==0:
            print("ERROR: ",avg_error)
        epoch -= 1
    
    print(c1, c2, c3)
    return wh1, wh2, wo, avg_err, a1, a2, ao

wh1, wh2, wo, avg_err, a1, a2, ao = train_data(training, tr1, tr2)



def test_data(wh1, wh2, wo, xn):
    pred_out = []
    neuron = []
    for i in range(len(xn)):
        
        xi = [1, xn.iat[i,0], xn.iat[i,1]]

        h1 = np.dot(wh1.T, xi)
        a1 = sigmoid(h1)
        
        h2 = np.dot(wh2.T, a1)
        a2 = sigmoid(h2)
        neuron.append(a2)
        out = np.dot(wo.T, a2) 
        ao = sigmoid(out) 
        
        pred_out.append(ao)
        
    return np.round(np.array(pred_out)), np.round(np.array(neuron))

all_points = []
for i in range(-10, 11):
    for j in range(-10, 11):
        all_points.append([i, j])
        
all_points = pd.DataFrame(all_points)

y , n= test_data(wh1, wh2, wo, all_points)

c1x, c2x, c3x = [], [], []
c1y, c2y, c3y = [], [], []

for i in range(len(all_points)):
        
    if y[i][0] == 1:
        c1x.append(all_points.iloc[i, 0])
        c1y.append(all_points.iloc[i, 1])
    elif y[i][1] == 1:
        c2x.append(all_points.iloc[i, 0])
        c2y.append(all_points.iloc[i, 1])
    else:
        c3x.append(all_points.iloc[i, 0])
        c3y.append(all_points.iloc[i, 1])
    


plt.scatter(c1x, c1y, marker='s', s=250)
plt.scatter(c2x, c2y, marker='s', s=250)
plt.scatter(c3x, c3y, marker='s', s=250)



plt.legend(['Class 1','Class 2', 'Class 3'])
plt.legend(['Class 1','Class 2', 'Class 3'], bbox_to_anchor=(1.04,1), loc="upper left")


plt.scatter(class1[0], class1[1], edgecolors='black')
plt.scatter(class2[0], class2[1], edgecolors='black')
plt.scatter(class3[0], class3[1], edgecolors='black')

plt.title("Decision Boundary")
plt.tight_layout()
plt.xlim(-10, 10)
plt.ylim(-10, 10)

plt.show()

plt.plot(avg_err)
plt.title("Average Error vs Epoch")
plt.xlabel("Epoch")
plt.ylabel("Average Error")
plt.show()

def confusion_matrix(yp, l1, l2):
    matrix = 0
    c11, c12, c13, c21, c22, c23, c31, c32, c33 = 0, 0, 0, 0, 0, 0, 0, 0, 0
    for i in range(len(yp)):
        if i<l1:
            if yp[i][0] == 1:
                c11 += 1
            elif yp[i][1] == 1:
                c12 += 1
            else:
                c13 += 1
        elif i>=l1 and i< (l1+l2):
            if yp[i][1] == 1:
                c22 += 1
            elif yp[i][0] == 1:
                c21 += 1
            else:
                c23 += 1
        else:
            if yp[i][2] == 1:
                c33 += 1
            elif yp[i][0] == 1:
                c31 += 1
            else:
                c32 += 1
    
            
    return [[c11, c12, c13], [c21, c22, c23], [c31, c32, c33]]

yp , neuron_t= test_data(wh1, wh2, wo, testing)
matrix = confusion_matrix(yp, len(test1), len(test2))
[c11, c12, c13], [c21, c22, c23], [c31, c32, c33] = matrix
print(np.array(matrix))

accuracy = (c11+c22+c33)/((len(test1)+len(test2)+len(test3)))*100
print('Accuracy = {}%'.format(accuracy))

def function(x, y):
    return x/(x+y)

def function1(x, y):
    if((x+y)==0):
        return 0.0
    else:
        return (2*x*y)/(x+y)

precision_1 = function(c11/2, c12+c13)
precision_2 = function(c22/2, c21+c23)
precision_3 = function(c33/2, c31+c32)
print('Precision\nClass1 = {}, Class2 = {}, Class3 = {}'.format(precision_1, precision_2, precision_3))

print("Average Precision: ", (precision_1+precision_2+precision_3)/3)

recall_1 = function(c11/2, c21+c31)
recall_2 = function(c22/2, c12+c32)
recall_3 = function(c33/2, c13+c23)
print('Recall\nClass1 = {}, Class2 = {}, Class3 = {}'.format(recall_1, recall_2, recall_3))

print("Average Recall: ", (recall_1+recall_2+recall_3)/3)

f_measure1 = (2*precision_1*recall_1)/(precision_1+recall_1)
f_measure2 = (2*precision_2*recall_2)/(precision_2+recall_2)
f_measure3 = (2*precision_3*recall_3)/(precision_1+recall_3)
print('F Score\nClass1 = {}, Class2 = {}, Class3 = {}'.format(f_measure1, f_measure2, f_measure3))

print("Average F-measure: ", (f_measure1+f_measure2+f_measure3)/3)

"""for training"""

yp , neuron_tr= test_data(wh1, wh2, wo, training)
fig = plt.figure(figsize = (17,6))
ax = plt.axes(projection='3d')
scat = ax.scatter(training.iloc[:,0], training.iloc[:,1],  neuron_tr[:,0], c=neuron_tr[:,0], cmap="winter")
plt.colorbar(scat)
plt.title("Output of Hidden node")
plt.xlabel("input feature 1")
plt.ylabel("input feature 2")
ax.set_zlabel("Neuron 1 output")

plt.show()

fig = plt.figure(figsize = (17,6))
ax = plt.axes(projection='3d')
scat = ax.scatter(training.iloc[:,0], training.iloc[:,1],  neuron_tr[:,2], c=neuron_tr[:,2], cmap="winter")
plt.colorbar(scat)
plt.title("Output of Hidden node")
plt.xlabel("input feature 1")
plt.ylabel("input feature 2")
ax.set_zlabel("Neuron 2 output")

plt.show()

fig = plt.figure(figsize = (17,6))
ax = plt.axes(projection='3d')
scat = ax.scatter(testing.iloc[:,0], testing.iloc[:,1],  neuron_t[:,2], c=neuron_t[:,2], cmap="winter")
plt.colorbar(scat)
#ax.scatter3D(testing.iloc[:,0], testing.iloc[:,1], neuron_t[:,0], color='green')
plt.title("Output of Hidden node")
plt.xlabel("input feature 1")
plt.ylabel("input feature 2")
ax.set_zlabel("Neuron 3 output")

plt.show()

"""for validation"""

yp , neuron= test_data(wh1, wh2, wo, validation)
fig = plt.figure(figsize = (17,6))
ax = plt.axes(projection='3d')
scat = ax.scatter(validation.iloc[:,0], validation.iloc[:,1],  neuron[:,0], c=neuron[:,0], cmap="winter")
plt.colorbar(scat)
plt.title("Output of Hidden node")
plt.xlabel("input feature 1")
plt.ylabel("input feature 2")
ax.set_zlabel("Neuron 1 output")

plt.show()

yp , neuron= test_data(wh1, wh2, wo, validation)
fig = plt.figure(figsize = (17,6))
ax = plt.axes(projection='3d')
scat = ax.scatter(validation.iloc[:,0], validation.iloc[:,1],  neuron[:,1], c=neuron[:,1], cmap="winter")
plt.colorbar(scat)
plt.title("Output of Hidden node")
plt.xlabel("input feature 1")
plt.ylabel("input feature 2")
ax.set_zlabel("Neuron 2 output")

plt.show()

yp , neuron= test_data(wh1, wh2, wo, validation)
fig = plt.figure(figsize = (17,6))
ax = plt.axes(projection='3d')
scat = ax.scatter(validation.iloc[:,0], validation.iloc[:,1],  neuron[:,2], c=neuron[:,2], cmap="winter")
plt.colorbar(scat)
plt.title("Output of Hidden node")
plt.xlabel("input feature 1")
plt.ylabel("input feature 2")
ax.set_zlabel("Neuron 2 output")

plt.show()

"""for testing """

yp , neuron= test_data(wh1, wh2, wo, testing)
fig = plt.figure(figsize = (17,6))
ax = plt.axes(projection='3d')
scat = ax.scatter(testing.iloc[:,0], testing.iloc[:,1],  neuron[:,0], c=neuron[:,0], cmap="winter")
plt.colorbar(scat)
plt.title("Output of Hidden node")
plt.xlabel("input feature 1")
plt.ylabel("input feature 2")
ax.set_zlabel("Neuron 1 output")

plt.show()

yp , neuron= test_data(wh1, wh2, wo, testing)
fig = plt.figure(figsize = (17,6))
ax = plt.axes(projection='3d')
scat = ax.scatter(testing.iloc[:,0], testing.iloc[:,1],  neuron[:,1], c=neuron[:,1], cmap="winter")
plt.colorbar(scat)
plt.title("Output of Hidden node")
plt.xlabel("input feature 1")
plt.ylabel("input feature 2")
ax.set_zlabel("Neuron 2 output")

plt.show()

yp , neuron= test_data(wh1, wh2, wo, testing)
fig = plt.figure(figsize = (17,6))
ax = plt.axes(projection='3d')
scat = ax.scatter(testing.iloc[:,0], testing.iloc[:,1],  neuron[:,2], c=neuron[:,2], cmap="winter")
plt.colorbar(scat)
plt.title("Output of Hidden node")
plt.xlabel("input feature 1")
plt.ylabel("input feature 2")
ax.set_zlabel("Neuron 2 output")

plt.show()

